import 'package:flutter/foundation.dart';
import '../models/design_tokens.dart';
import '../../features/context/data/models/context_document.dart';
import '../../features/context/data/repositories/context_repository.dart';

/// Service for managing design tokens from context library
///
/// Week 3: Provides design tokens to MCPPenpotServer for brand-consistent designs
class DesignTokensService {
  final ContextRepository contextRepository;
  DesignTokens? _cachedTokens;

  DesignTokensService({required this.contextRepository});

  /// Get design tokens from context library
  ///
  /// Searches for context documents tagged with 'design-tokens' or 'design-system'
  /// Falls back to default tokens if none found
  Future<DesignTokens> getDesignTokens() async {
    // Return cached if available
    if (_cachedTokens != null) {
      return _cachedTokens!;
    }

    try {
      // Get all context documents
      final documents = await contextRepository.getDocuments();

      // Look for design tokens document
      final tokensDoc = documents.firstWhere(
        (doc) =>
            doc.tags.contains('design-tokens') ||
            doc.tags.contains('design-system') ||
            doc.title.toLowerCase().contains('design tokens') ||
            doc.title.toLowerCase().contains('design system'),
        orElse: () => _createDefaultTokensDocument(),
      );

      // Parse tokens from document content
      final tokens = DesignTokens.fromMarkdown(tokensDoc.content);

      // Cache for future use
      _cachedTokens = tokens;

      debugPrint('✅ Design tokens loaded from context library');
      return tokens;
    } catch (e) {
      debugPrint('⚠️ Error loading design tokens: $e, using defaults');
      return DesignTokens.defaultTokens();
    }
  }

  /// Get design tokens synchronously (returns cached or defaults)
  DesignTokens getDesignTokensSync() {
    return _cachedTokens ?? DesignTokens.defaultTokens();
  }

  /// Clear cached tokens (force reload on next get)
  void clearCache() {
    _cachedTokens = null;
  }

  /// Create or update design tokens in context library
  Future<void> saveDesignTokens(DesignTokens tokens) async {
    try {
      // Get all context documents
      final documents = await contextRepository.getDocuments();

      // Look for existing design tokens document
      final existingDoc = documents.cast<ContextDocument?>().firstWhere(
            (doc) =>
                doc != null &&
                (doc.tags.contains('design-tokens') ||
                    doc.tags.contains('design-system')),
            orElse: () => null,
          );

      // Format as markdown with JSON
      final content = _formatTokensAsMarkdown(tokens);

      if (existingDoc != null) {
        // Update existing document
        final updatedDoc = existingDoc.copyWith(
          content: content,
          updatedAt: DateTime.now(),
        );
        await contextRepository.updateDocument(updatedDoc);
        debugPrint('✅ Design tokens updated in context library');
      } else {
        // Create new document
        await contextRepository.createDocument(
          title: 'Design Tokens',
          content: content,
          type: ContextType.guidelines,
          tags: ['design-tokens', 'design-system', 'penpot'],
          metadata: {'auto_generated': true},
        );
        debugPrint('✅ Design tokens created in context library');
      }

      // Update cache
      _cachedTokens = tokens;
    } catch (e) {
      debugPrint('❌ Error saving design tokens: $e');
      rethrow;
    }
  }

  /// Format tokens as markdown document
  String _formatTokensAsMarkdown(DesignTokens tokens) {
    final json = tokens.toJson();
    final jsonStr = _prettyPrintJson(json);

    return '''# Design Tokens

Design tokens for consistent brand implementation across all designs.

## Usage

These tokens are automatically applied by the design agent when creating Penpot designs.

## Token Specification

\`\`\`json
$jsonStr
\`\`\`

## Color Palette

- **Primary**: ${tokens.colors.primary}
- **Secondary**: ${tokens.colors.secondary}
- **Accent**: ${tokens.colors.accent}
- **Text**: ${tokens.colors.text}
- **Background**: ${tokens.colors.background}
- **Surface**: ${tokens.colors.surface}

## Typography

- **Heading Font**: ${tokens.typography.headingFont}
- **Body Font**: ${tokens.typography.bodyFont}
- **Base Size**: ${tokens.typography.baseSize}px

## Spacing

- **Unit**: ${tokens.spacing.unit}px
- **Scale**: ${tokens.spacing.scale.entries.map((e) => '${e.key}: ${e.value}px').join(', ')}

---

*Auto-generated by Asmbli Design System*
''';
  }

  /// Pretty print JSON with indentation
  String _prettyPrintJson(Map<String, dynamic> json) {
    const encoder = JsonEncoder.withIndent('  ');
    return encoder.convert(json);
  }

  /// Create a default tokens document (not saved to repository)
  ContextDocument _createDefaultTokensDocument() {
    final tokens = DesignTokens.defaultTokens();
    return ContextDocument(
      id: 'default_tokens',
      title: 'Default Design Tokens',
      content: _formatTokensAsMarkdown(tokens),
      type: ContextType.guidelines,
      tags: ['design-tokens', 'default'],
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
      isActive: true,
      metadata: {'default': true},
    );
  }
}

/// Simple JSON encoder for pretty printing
class JsonEncoder {
  final String indent;

  const JsonEncoder.withIndent(this.indent);

  String convert(Map<String, dynamic> object, [int depth = 0]) {
    final buffer = StringBuffer();
    buffer.writeln('{');

    final entries = object.entries.toList();
    for (var i = 0; i < entries.length; i++) {
      final entry = entries[i];
      final isLast = i == entries.length - 1;

      buffer.write(indent * (depth + 1));
      buffer.write('"${entry.key}": ');

      if (entry.value is Map) {
        buffer.write(convert(entry.value as Map<String, dynamic>, depth + 1));
      } else if (entry.value is String) {
        buffer.write('"${entry.value}"');
      } else {
        buffer.write(entry.value);
      }

      if (!isLast) {
        buffer.write(',');
      }
      buffer.writeln();
    }

    buffer.write(indent * depth);
    buffer.write('}');

    return buffer.toString();
  }
}
